<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 遗传算法入门 · SPIKE</title><meta name="description" content="遗传算法入门 - Spike Joe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://spikezz.com/atom.xml" title="SPIKE"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/zpike" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://twitter.com/zshe404" target="_blank" class="nav-list-link">TWITTER</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">遗传算法入门</h1><div class="post-info">Mar 5, 2017</div><div class="post-content"><p>遗传算法（Genetic Algorithm，简称GA）是一类借鉴生物界的进化规律（适者生存，优胜劣汰遗传机制）演化而来的随机化搜索方法，由美国的J.Holland教授1975年首先提出。遗传算法是一种模拟达尔文的遗传选择和自然淘汰的生物进化过程的计算模型，通过模拟自然进化过程搜索最优解，它常用来解决多约束条件下的最优问题。</p>
<a id="more"></a>
<h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法:"></a>遗传算法:</h2><p><em>优点</em>：根据XY染色体的配对关系能够准确的寻找工艺生产搭配方式，又根据优胜劣汰的生物竞争法则寻找最佳搭配方式，最终寻找出最优的生产路径。</p>
<ol>
<li>与问题领域无关切快速随机的搜索能力。</li>
<li>搜索从群体出发，具有潜在的并行性，可以进行多个个体的同时比较，robust.</li>
<li>搜索使用评价函数启发，过程简单</li>
<li>使用概率机制进行迭代，具有随机性。</li>
<li>具有可扩展性，容易与其他算法结合。</li>
</ol>
<p><em>缺点</em>： 依赖初始条件，条件的更改反应慢。对应时常更改需求的应用来说是一个挑战。</p>
<ol>
<li>没有能够及时利用网络的反馈信息,故算法的搜索速度比较慢，要得要较精确的解需要较多的训练时间。</li>
<li>算法对初始种群的选择有一定的依赖性，能够结合一些启发算法进行改进。</li>
<li>算法的并行机制的潜在能力没有得到充分的利用，这也是当前遗传算法的一个研究热点方向。</li>
</ol>
<h2 id="神经网络："><a href="#神经网络：" class="headerlink" title="神经网络："></a>神经网络：</h2><p><em>优点</em>：神经网络有很强的非线性拟合能力，可映射任意复杂的非线性关系，而且学习规则简单，便于计算机实现。具有很强的鲁棒性、记忆能力、非线性映射能力以及强大的自学习能力，因此有很大的应用市场。</p>
<p><em>缺点</em>:</p>
<ol>
<li>最严重的问题是没能力来解释自己的推理过程和推理依据。通过寻找神经元、组合神经元的方式获得路径。</li>
<li>不能向用户提出必要的询问，而且当数据不充分的时候，神经网络就无法进行工作。</li>
<li>把一切问题的特征都变为数字，把一切推理都变为数值计算，其结果势必是丢失信息。</li>
<li>理论和学习算法还有待于进一步完善和提高。</li>
</ol>
<h2 id="基因算法"><a href="#基因算法" class="headerlink" title="基因算法"></a>基因算法</h2><p>基因算法GA（Genetic Algorithm）是基于自然系统的进化过程，算法创立一个初始化方案，基于初始化方案，算法再产生一个新的方案，通过许多代的连续方案，方案的质量被改善，算法结束于一个特别的中断规则。GA实际上是一种搜寻算法，已经用于许多优化问题，如销售员旅行问题，排程问题，设施布局问题等。</p>
<p>GA在搜索中比较目标函数值，接受临时的方案来克服本地优化，找到全局优化。然而，GA是探索法，可能不是最佳方案，但是大部分情况下，至少可以找到一个非常好的可行方案。</p>
<p>GA算法的核心是基于自然选择，在实际案例中应用时不需去“找”最优方案，只要不断“否定”表现不好的方案，最终会得到一个“最优解”，但是不一定是一个最优解。</p>
<p>GA算法的基本三个步骤：复制 –&gt; 交叉 –&gt; 变异</p>
<p>具体一点：</p>
<ul>
<li>初始化Initialization（创造一个初始化解的集合，通常是随机解）</li>
<li>评估Evaluation（集合中每个个体都被评估，按照需求计算评估值，复杂度不一）</li>
<li>选择Selection（去除掉不好的解，保留好的解）</li>
<li>交叉Crossover（组合每个解的个体，形成新的解，自然选择）</li>
<li>变异Mutation（增加一点随机性，增加更多好的解）</li>
<li>重复Repeat（从第二步开始重复，知道终结条件满足）</li>
</ul>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="http://oc1hnrd8p.bkt.clouddn.com/photos/20170309/093136321.png" alt="mark"></p>
<p><strong>种群(Population)</strong>: 生物的进化以群体的形式进行，这样的一个群体称为种群<br>个体： 组成群体的单个生物<br>基因(Gene)：一个遗传因子<br>染色体：包含一组的基因</p>
<p><strong>编码</strong>： 需要将问题的解编码成字符串的形式才能使用遗传算法。最简单的一种编码方式是二进制编码，即将问题的解编码成二进制位数组的形式。</p>
<p><strong>选择</strong>：选择一些染色体来产生下一代。一种常用的选择策略是 “比例选择”，也就是个体被选中的概率与其适应度函数值成正比。</p>
<p><strong>交叉(Crossover)</strong>：2条染色体交换部分基因，来构造下一代的2条新的染色体。</p>
<p><strong>变异(Mutation)</strong>：在繁殖过程，新产生的染色体中的基因会以一定的概率出错，称为变异。</p>
<p><strong>适应度函数 ( Fitness Function )</strong>：用于评价某个染色体的适应度，用f(x)表示。有时需要区分染色体的适应度函数与问题的目标函数。</p>
<p>基本遗传算法伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* Pc：交叉发生的概率</div><div class="line">* Pm：变异发生的概率</div><div class="line">* M：种群规模</div><div class="line">* G：终止进化的代数</div><div class="line">* Tf：进化产生的任何一个个体的适应度函数超过Tf，则可以终止进化过程</div><div class="line">*/</div><div class="line">初始化Pm，Pc，M，G，Tf等参数。随机产生第一代种群Pop</div><div class="line"></div><div class="line">do</div><div class="line">&#123; </div><div class="line">　　计算种群Pop中每一个体的适应度F(i)。</div><div class="line">　　初始化空种群newPop</div><div class="line">　　do</div><div class="line">　　&#123;</div><div class="line">　　　　根据适应度以比例选择算法从种群Pop中选出2个个体</div><div class="line">　　　　if ( random ( 0 , 1 ) &lt; Pc )</div><div class="line">　　　　&#123;</div><div class="line">　　　　　　对2个个体按交叉概率Pc执行交叉操作</div><div class="line">　　　　&#125;</div><div class="line">　　　　if ( random ( 0 , 1 ) &lt; Pm )</div><div class="line">　　　　&#123;</div><div class="line">　　　　　　对2个个体按变异概率Pm执行变异操作</div><div class="line">　　　　&#125;</div><div class="line">将2个新个体加入种群newPop中</div><div class="line">&#125; until ( M个子代被创建 )</div><div class="line">用newPop取代Pop</div><div class="line">&#125;until ( 任何染色体得分超过Tf， 或繁殖代数超过G )</div></pre></td></tr></table></figure></p>
<p>常见问题：</p>
<p>1、在选择的过程中，选择多少次，会不会造成种群的减少，选到重复的怎么办？</p>
<p>答：选择次数没有限制，即然是选择肯定就会有没选上的，因此会造成种群数量减少，选到重复的个体舍弃重新选择。建议选择的次数少于种群数量，因为不重复，因此当次数为种群数量时即全部选择了，这样就失去了选择的意义。舍弃重复的是因为重复的个体对种群的差异化没有帮忙（试想极端情况下全是重复个体，那么交叉后全是一样的，没有意义）。</p>
<p>2、 即然计算出了种群中每个个体的适应度，为什么不直接选择适应度高的，舍弃适应度低的，而要用其他算法来选择？</p>
<p>答：适应度低的个体也可能存在优质基因。现实生活中的例子：一对傻子生了个聪明儿子。</p>
<p>3、交叉的过程是随机交叉还是两两交叉，交叉多少次合适？</p>
<p>答：随机或两两交叉都可以，交叉次数大于或等于初始种群中个体数量/2。因为交叉一次产生两个新个体，而第3步的变异不产生新个体，因此为保证种群中个体的数量不致于越来越少（人口负增长）， 交叉次数大于或等于初始种群中个体数量/2。</p>
<p><strong>整体设计流程：</strong></p>
<p>编码–&gt;适应度函数的设计–&gt;遗传算子的设计(选择算子，交叉算子，变异算子)–&gt;实施流程图</p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>一个实际问题最关键的步骤是对任务及工序<strong>编码</strong>。比如对工厂编号的编码，用数字表示：1，2，3..</p>
<p>对任务的编码：J01，J02，J03..</p>
<p>工序和任务相结合之后，形成一个完整的染色体，染色体其实就是某项工序和某项任务的结合体，编码结果可能是：<br>1J03-2J02-2J02-1J02-2J04-1J03-2J02-1J01</p>
<p>对其分析一下：两家工厂，四个任务，依次出现的次序是03-02-04-01</p>
<p>然后就是<strong>杂交</strong>过程，即随机交换部分基因代码，工序不受影响，包含所有祖先的信息，对杂交结果需需修正（重复）或者补偿（缺少）。</p>
<p>然后是<strong>变异</strong>。变异的用处是避免过早收敛，从而得不到最优解。一般分两次变异。第一次变异是局部遗传操作（随机）；第二次变异是全局遗传操作。</p>
<p>然后是<strong>适应度函数</strong>的设计，遵循的规则一般有“最小生产周期”或者“最小生产成本”。</p>
<p>然后是<strong>复制</strong>。这个过程中优秀的染色体能获得更高的生产概率，从而在迭代过程中出现的次数更多。</p>
<p>最后是<strong>判断是否最优</strong>。条件一般是：1.最佳个体在迭代中出现的次数；2.预先设定的算法迭代次数达到。</p>
<p><code>参考链接：</code></p>
<p><a href="https://www.doc.ic.ac.uk/~nd/surprise_96/journal/vol1/hmw/article1.html" target="_blank" rel="external">GA算法介绍</a><br><a href="http://www.theprojectspot.com/tutorial-post/creating-a-genetic-algorithm-for-beginners/3" target="_blank" rel="external">GA算法的JAVA实现</a><br><a href="http://www.theprojectspot.com/tutorial-post/applying-a-genetic-algorithm-to-the-travelling-salesman-problem/5" target="_blank" rel="external">在TSP(旅行最佳路线问题)问题上应用GA算法</a><br><a href="http://www.w3ii.com/genetic_algorithms/default.html" target="_blank" rel="external">基因算法教程</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/02/20/auto-deploy-hexo-on-travis-ci/" class="prev">上一篇</a><a href="/2017/03/08/nas-based-on-pi/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'spikezhou';
var disqus_identifier = '2017/03/05/genetic-algorithm/';
var disqus_title = '遗传算法入门';
var disqus_url = 'http://spikezz.com/2017/03/05/genetic-algorithm/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//spikezhou.disqus.com/count.js" async></script><div id="gitment"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  owner: 'zpike',
  repo: 'https://github.com/zpike/learngit.git',
  oauth: {
    client_id: 'd9bce1ba3bb8dc2ecfd7',
    client_secret: 'b049c233100d2bceb566cb297c99357d363f8476',
  },
})
gitment.render('container')</script><div class="copyright"><p>© 2015 - 2017 <a href="http://spikezz.com">Spike Joe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/zpike/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>