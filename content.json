[{"title":"npm 简介","date":"2017-07-07T01:57:35.000Z","path":"2017/07/07/what-is-npm/","text":"随着JavaScript的流行，相关工具的使用也变得非常重要。npm是出现的一个小公举，类似的工具还有Yarn，不过目前npm还是更加普及一点。稍微查了下他们的区别，说是Yarn更好一点，更多大牛更加推荐。不过很多项目用的还是npm管理，比如之前介绍的hexo的安装包。 npm全称是node package manager，所以它本质上就是个包管理器。类似mac上的神器，brew。不过npm只是用来管理nodejs的。这样开发js应用的时候，就可以大量使用前端库，并且保持较好的版本控制。为什么说“较好”，版本控制是个坑。很多构建的问题，据说都可以归到npm的头上，使用Yarn貌似能解决这一问题。 要使用npm首先要安装node，Mac中用brew先安装node再说。 1$ brew install node 查看一下版本号，发现npm不是最新，然后更新一下npm，怎么更新呢？用自己更新自己！ 1$ npm i -g npm 你会发现有个-g参数，这个参数是用来全局安装npm的，不过很多插件都是本地安装的，比如很多项目才需要的插件，安装在全局会很乱，也不好管控各种版本，但是又有的插件经常用到，比如grunt-cli之类，就需要安装在全局。所以原则是，依情况而定。 一般来说下面几个是建议安装在全局的。 1234$ npm install -g coffee-script$ npm install -g less$ npm install -g grunt-cli$ npm install -g gulp 先看看，这些工具暂时用不到的就不用研究，用到再学习不迟。 然后是npm的包安装。命令如下： 12$ npm i &lt;packagename&gt; //安装在当前目录下$ npm i -g &lt;packagename&gt; //安装在全局 这样是一个个包分别安装，太麻烦了！ 怎么批量安装呢？ 装过hexo的都知道，目录下面有个package.json文件，这个文件就是用来配置需要安装的包们的。打开看一下，发现好复杂！不过稍微仔细看一下，发现depedencise下面就是包名字加版本号。然后在目录下面运行： 1$ npm install --save //--sava用来修改json文件的包依赖关系 就会在当前目录下面安装所有的包至node_modules这目录下面了。 更新安装的包： 12$ npm outdated [-g] //查看哪些过期了$ npm update [-g] //更新包 手动维护package.json中的包版本实在麻烦，介绍一个插件，npm-upgrade，这个插件可以检查json文件中包的版本号，然后更新。 不过npm社区真是日新月异，好多包之前装的，更新一下发现都“deprecated”了，前端真是前景巨大啊。","tags":[{"name":"npm js","slug":"npm-js","permalink":"http://zhzhou.me/tags/npm-js/"}]},{"title":"git checkout 的使用","date":"2017-06-02T07:33:08.000Z","path":"2017/06/02/git-checkout-usage/","text":"Git命令中，我个人感觉最重要的命令就是git checkout了。这个命令简单来说是Git的精髓–分支管理。当然对新手来说也是比较难以理解的概念之一。记得刚开始用git的时候，git checkout这个命令还是蛮令我困惑的。困惑之一就是远程分支和本地分支的管理上。比如怎么把远程不同于master分支的东西弄到本地，怎么在不同分支之间切换自如，利用分支的优势为自己开发所用等。 首先，git checkout一般和git branch配合使用。不过也可以直接git checkout -b，即“创建并切换分支”。 一般做改动，建议直接创建一个分支，因为在master上直接改动，万一搞乱了，虽然可以时光倒流，但是毕竟还是保持几个版本比较方便，新的特性也能方便的做对比。这个就是为什么git项目文件夹可能很大，但是进去文件夹发现没什么文件的原因。因为其它分支都被”隐藏”起来了嘛！ 一般教程也就到这就结束了，其实还有很多常用的东西没讲。比如远程上面有个分支，我想弄到本地来。经常遇到的一个情况就是远程上面的某个分支有我需要的内容，我怎么获取到本地呢？ 先看一下远程有哪些分支： 1git branch -r 然后拉取远程分支，并创建本地分支：1git checkout -b &lt;本地分支名&gt; origin/&lt;远程分支名&gt; 如果想远程分支名和本地分支名一样，也可以用 --track 这个选项。 1git checkout -t origin/&lt;远程分支名&gt; 以上当然也可以用git fetch来做，区别只是会先fetch到repository，然后手动切换到工作分支。 12git fetch origin &lt;远程分支名&gt;:&lt;本地分支名&gt;git checkout &lt;本地分支名&gt; 远程操作上可能会出现很多问题，比如什么merge conflict之类，新手可以打开gitk看看，还有tower神器。不过感觉还是要先了解命令行，才能更好的用这些图形化界面。有点鸡生蛋，蛋生鸡的味道。 参考链接： 阮一峰博客 Man Page","tags":[{"name":"git","slug":"git","permalink":"http://zhzhou.me/tags/git/"}]},{"title":".gitignore文件的使用","date":"2017-05-26T06:33:31.000Z","path":"2017/05/26/gitignore-usage/","text":"用上GitHub之后似乎什么项目都想push一下，新手在用git相关命令难免有些问题。有很多问题似乎是过了很久我才明白的，虽然间间断断用git也很长时间了。这些问题类似“vim退出”之类，不过新手确实难免会碰到。这里做点记录，方便自己和后来人。 git项目中如果想要忽略掉某个文件，不让它出现在版本库中，比如.DS_Store之类的文件，可以在项目根目录中修改.gitignore文件，这个文件一般不用自己创建，也不大需要修改，有些IDE会自己给你弄好。但是有的时候还是需要自己手动修改一下，比如有的文件中包含了你数据库的密码，当然就不能出现在github上了。 修改.gitignore文件很简单，一行一行输入不需要放到版本库里面的文件或文件夹名即可。 不过有的时候push过之后，然后修改了.gitignore，每次git status会出现Untracked files...之类的提示。这是因为文件已经被版本管理了！文件已经被track了。如果需要解决这个问题，就需要删除掉本地的缓存文件，变成untrack状态。 步骤如下： 123git rm -r --cached . git add .git commit -m &quot;update .gitignore&quot; 再次git status，发现clean了，完美。 相关链接： 半官方资料 廖雪峰教程","tags":[{"name":"git","slug":"git","permalink":"http://zhzhou.me/tags/git/"}]},{"title":"Mac OSX上安装 Java","date":"2017-04-19T00:17:38.000Z","path":"2017/04/19/install-java-on-mac/","text":"在Mac上安装Java，之前都是在官方网站下载安装包，这样当然不怎么方便，所以自然就想到用homebrew安装了。查了一下，果然有办法，而且可以保持几个不同版本的JDK，方便不同版本测试。 这个方法就是使用jenv，这个东西是基于rbenv开发的，不同的是rbenv是为了管理ruby，jenv是为了管理java。用jenv之后，就不用设置什么$JAVE_HOME变量了。而且可以方便切换各种不同版本的JDK，方便调试。 主要步骤： 安装 brew-cask 12brew updatebrew install caskroom/cask/brew-cask 安装 jenv 123brew install jenvecho &apos;export PATH=&quot;$HOME/.jenv/bin:$PATH&quot;&apos; &gt;&gt; ~/.zshrcecho &apos;eval &quot;$(jenv init -)&quot;&apos; &gt;&gt; ~/.zshrc 安装最新版本的Java 1brew cask install java 然后看看brew把Java安装到哪里去了，一般在如下位置 1jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/ 然后在$HOME目录下加一个.java-version文件，里面写个1.8，结束。 下面具体谈谈具体细节。 首先Jenv是用来干啥的？ 主要是用来管理不同版本的Java的，什么Oracle JDK，OpenJDK等。可以去官网看看。 在OSX中所有JVM都安装在 /Library/Java/JavaVirtualMachines/下，所以上面第四步添加安装的版本到jenv中。 查看安装了那些JDK版本。12345~ ᐅ jenv versions system* 1.8 (set by /Users/Spike/.java-version) 1.8.0.121 oracle64-1.8.0.121 配置全局版本号1$ jenv global oracle64-1.6.0.39 配置本地版本号1jenv local oracle64-1.6.0.39 配置Shell版本号1jenv shell oracle64-1.6.0.39 生成 Shimsjenv可以将所有安装过的Java版本中的bin目录集合管理，即~/.jenv/versions/*/bin/*中的所有东西都放到shims文件夹下。每次安装完新版本都运行jenv rehash即可。 1$ jenv rehash 参考资料： Master your Java Environnement with jenv Install Java 1.8 on Mac OS El Capitan","tags":[]},{"title":"终极 vimrc","date":"2017-04-18T05:17:04.000Z","path":"2017/04/18/the-ultimate-vimrc/","text":"使用vim需要配置自己的vimrc，用一个基本的vimrc，然后在这个基础之上学习各种添加方式也是学习的必经步骤。各种插件的安装使用，然后用各种插件管理器，比如Vundle或者pathogen，各种折腾vim也是乐趣之一。 不过如果一开始就用上一个大牛配置好的vimrc，然后学习他的使用方法，尽快熟悉vim的各种牛逼技能，也不能算是一个偷懒的方法。特别对于vim这种学习曲线比较陡峭的神器来说。学习Emacs我觉得也可以用同一种方法，用人家配置好的方便的配置文件，即能迅速入门，又能体会神器之神，何乐而不为。 github上找了一个号称终极vimrc的配置。看了一下适合高手也适合新手。里面有两个版本，一个基础配置，一个终极配置。只要在vimrc文件里面打开关闭即可，很方便。 终极版本主要配置了以下几点： 对Python文件的语法颜色搭配。打开最近编辑过的文档。目录结构Nerd tree。免打扰模式。几个比较好看的主题。几个常用模式。等等。 这些就不多说了，感觉光插件就够研究好久的。慢慢提高吧。","tags":[{"name":"vim","slug":"vim","permalink":"http://zhzhou.me/tags/vim/"}]},{"title":"在 MAMP 中安装 Tomcat","date":"2017-04-15T05:29:17.000Z","path":"2017/04/15/install-tomcat-in-mamp/","text":"部署网络开发环境，Apache是一定要遇到的。如果更加深入研究，还要看http协议什么的。如果要学习JSP或者Servlet，Tomcat 就会出现了。两者的区别，从开发语言上看，Http Server是用C开发的，Tomcat是用纯Java开发的。Tomcat 用来部署 JSPs 和 Java Servlet，是服务于Java类的技术的（毕竟是自己开发的嘛）。所以可以将Tomcat看做是一个Servlet的容器，Java项目中，将产生的WAR文件，放到tomcat部署的文件夹下就可以了。 基于前面的网络部署，在Mac下还是用MAMP开发，但是普通版本没有自带Tomcat，所以怎么将Tomcat放到这里面呢？ 首先下载 Tomcat，目前8.5的版本是最新的稳定的版本，当然追新的也可以用版本9.0，貌似还是alpha，所以还是用个稳定的版本先学习下。 版本对比： 关于软件的版本控制，在网络开发中还是比较麻烦的。IDE工具可以配置各种版本的软件，但是命令行下面，如何方便的管理不同版本，还真比较需要多注意。当然homebrew做得不错，很多版本差异的问题可以得到解决。其他软件，安装源代码的时候也需要注意区分。不过这是另外一个话题，以后再说。 安装好了MAMP之后，下载好Tomcat，解压到默认文件夹。然后放到MAMP文件夹下。应该是： /Applications/MAMP/apache-tomcat-8.5.13 然后在MAMP目录下，创建一个tomcat文件夹的链接：（这样就不用在意版本号了，方便各种配置命令）12cd /Applications/MAMPln -s /Applications/MAMP/apache-tomcat-8.5.13 tomcat 将tomcat目录下的bin文件夹下所有sh文件都加个执行的权限：12cd /Applications/MAMP/tomcat/binls -l *.sh | xargs chmod +x 修改apache启动文件（/Applications/MAMP/bin/startApache.sh），最后加一行：1/Applications/MAMP/tomcat/bin/startup.sh 修改apache的停止文件（/Applications/MAMP/bin/stopApache.sh），如下：12345678# /bin/sh/Applications/MAMP/tomcat/bin/shutdown.sh/Applications/MAMP/Library/bin/apachectl stopsleep 2kill -TERM ps aux | grep [t]omcat | awk &apos;&#123; print $2&#125;&apos;sleep 1kill -9 ps aux | grep [t]omcat | awk &apos;&#123; print $2&#125;&apos; 其实也可以直接用 homebrew 安装，也方便管理。不过启动就不那么方便了。 安装：1$ brew install tomcat 运行：1$ /usr/local/Cellar/tomcat/[version]/bin/catalina run 然后浏览器查看是否运行。 配置： 1$ vim /usr/local/Cellar/tomcat/[version]/libexec/conf/tomcat-users.xml 最后面有几行注释掉的&lt;user 开头的内容，修改成如下： 1&lt;user username=&quot;admin&quot; password=&quot;password&quot; roles=&quot;tomcat,manager-gui&quot; /&gt; 然后在浏览器界面，点击Manager App 就可以管理应用了。","tags":[]},{"title":"MAMP 使用","date":"2017-04-15T05:28:48.000Z","path":"2017/04/15/MAMP-basics/","text":"对于搞网络开发的，基本上都要被开发环境的安装耗费点精力。不过个人感觉虽然很折腾，但是确实能学到点各个组件的一些特点，配置方法等。如果用集成得很好的软件，这其中的一些知识点就略过了。不过如果你弄个LAMP或者WAMP，对于集成得比较好的软件就会比较喜欢了。 用过一些集成开发环境的软件，比如XAMPP，WampServer，Usbwebserver等。这些软件都各有特点，用起来都还不错，当然有的还是不大稳定，或者对平台比较挑剔。试下来，建议windows就用WampServer，Mac的话就用MAMP。尤其是MAMP，做得很不错，而且还有Pro版本可以使用，对于初学者，免费版本其实就够了。 首先去官网下载，然后安装。最新版本是4.1.1，各个组件都做了相应的更新。对版本有要求的要稍微改一下对应的组件的版本号，就可以开始使用了。 端口是要注意的，新手可能在这边纠结，因为很多默认的端口不一致，比如在Jetbrains的IDE中开发，端口设置的一般是65543之类，要修改成MAMP的对应port，不然怎么搞都不行。当然也可以改MAMP的端口设置。不过我建议还是用它默认的端口，不容易冲突。 开发HTML或者PHP的，文件目录可以设置到自己常用的目录，或者也可以用默认的htdocs，建议使用自己的目录，比较不容易乱，也好找。 弄好之后应该可以用浏览器打开localhost了，看看相关参数，了解一下。mysql可以用phpMyAdmin查看管理。当然更深入的设置还是需要借助命令行。 配置文件都放在conf目录下，默认是没有mysql的配置文件的，即my.cnf 文件。模板要去support-files中去拷贝。 1cp /Applications/MAMP/Library/support-files/my-medium.cnf /Applications/MAMP/conf/my.cnf 但是貌似最新版本中没有了，老版本是有的，新版不知道将cnf文件模板放哪去了。不过这文件也很好下载。 还有修改 MySQL 的密码需求比较常见，也需要借助命令行。 1/Applications/MAMP/Library/bin/mysqladmin -u root -p password &lt;NEWPASSWORD&gt; 换成自己的密码即可。不过我感觉各种密码好乱，最好不要轻易修改，忘记密码的话挺麻烦。","tags":[]},{"title":"Kindle 更换字体","date":"2017-04-10T02:25:09.000Z","path":"2017/04/10/change-kindle-fonts/","text":"Kindle看书久了，稍微对中文字体的支持度比较不那么满意，所以搜索看看如何更换字体，发现只有越狱一条道路。不然只能用内嵌，但是书籍大小会变大，预料速度还会变慢。 所以还是越狱了吧。 中文字体确实大坑，如果涉及到中文书籍排版坑就更大了。这里只探讨一下indle用什么中文字体看书比较好。 但是首先还是要先越狱。步骤比较简单，但是也有出问题的可能。祝你好运。 关于越狱还是先看文末的几个链接。第一个链接最好，很详细，照着做基本不会出什么问题。 总结一下： 要越狱先要满足越狱条件。型号要对，并且离线模式。 然后就是降级固件。我这里是KV，降到5.50版本固件。 然后是安装几个插件。（重要步骤！）htmlviewer 和 hotfix 插件安装完成越狱过程就基本结束了，但是还有一步。 更新到最新固件，不更新的话貌似KUAL打不开。 然后是装两个必须的插件，一个是插件管理器，叫KUAL，这个必须的。 然后是一个MRPI，插件安装器。其实它是KUAL的插件，以后安装各种插件要通过它来安装。直接刷bin貌似固件不支持。 然后就越狱成功了。 之后要换Kindle字体的话，还需要装上 Font Hack 这个插件。可以看看官方指南。 要注意的是，这个方法暂时只能替换系统自带的四种字体。看书一般用宋体，或者黑体。 目前试过几种字体，比较流行的方正兰亭宋，思源黑，冬青黑等，当然还有刚出的思源宋。这些字体都不错，各有用处，适用场景非常多。目前我在用汉仪的[新人文宋](http://www.zcool.com.cn/article/ZMzk3ODU2.html)，感觉很适合看书。 这个字体是在微信读书app中发现的，试过感觉不错。（汉仪的中文字体确实不错，很有特色）还有就是个人感觉ppi高选宋体，低选黑体。 关于字体还真是很多门道，深究下去看书时间都不够了，还是多看几本书吧。 参考链接: how to jailbreak your Kindle Kindle 5.8.x 越狱教程：利用特制固件越狱 Kindle 中文字体推荐：更换一下字形口味","tags":[{"name":"Kindle","slug":"Kindle","permalink":"http://zhzhou.me/tags/Kindle/"}]},{"title":"基于 Rasperry Pi 3 的家用 NAS 搭建","date":"2017-03-07T16:00:00.000Z","path":"2017/03/08/nas-based-on-pi/","text":"最近感觉对于 NAS 的需求越来越多了，主要是因为电子设备的增多，想要将所有媒体文件以及文档都放到一个地方统一管理，然后在世界任何地方可以方便存取，查阅。这样的场景想想就诱人。 但是无奈群晖的 NAS 价格较高，个人用户还是比较难以承受的。不过很多其他方案可以实现，只是没有那么炫酷罢了。比如路由器自带的云存储，或者本篇文章要介绍的基于树莓派的家用 NAS 构建。 首先要用 NAS 当然要准备一个移动硬盘。目前可以选择的比较好的移动硬盘就那么几家，个人推荐WD的，或者希捷的，当然高富帅也可以选择Lacie，不过也就是样子货，还是简单实用就行了。 说道移动硬盘，最近出了SSD的移动硬盘，那玩意儿短期之内价格不会让人满意的，而且作为 NAS太浪费了。还是用传统的就好，用最新的 Pi 3 速度已经够一般使用了。 然后就是拿出你尘封已久的 Rasperry Pi 了，到这个网站下载镜像，然后就是安装系统了。关于镜像的选择，貌似网上很多，不过还是建议找最热门的，就是 OpenMediaVault，但是也有点问题，比如对名字中包含中文的文件的支持。总体上还是不错的，操作简单，方便。 OpenMediaVault 系统安装安装比较简单，主要步骤如下： 格式化树莓派的SD卡，格式化成FAT32格式； 下载镜像文件，解压，镜像格式img； 把精选写到SD卡上； 树莓派放到路由器旁，插上一根网线，然后上电； 等系统启动完毕，登录路由器界面，看到树莓派的ip地址，然后浏览器中输入ip地址，即可登录控制界面，默认登录用户名是：admin，密码：openmediavault。 然后就可以开始配置移动硬盘了。 OpenMediaVault 的使用配置只需要将移动硬盘挂载一下，在 web 界面下的 File Systems 中设置。 需要注意的是，每次配置好移动硬盘都需要 Apply 一下，其他操作也是如此。 然后是配置一下要分享的文件夹，在左边的 Shared Folders 中设置，选择好要分享的硬盘，就是刚刚挂载的移动硬盘。 要注意的是权限问题，管理挺麻烦的。自己家里用你就添加一个root帐号即可，所有权限都给。但是想要安全一点，还是需要多加限制。 最后就是使能 SMB/CFIS 分享功能，用过 iOS上的 nPlayer 的应该比较熟悉。添加刚刚设置好的分享的文件夹，结束。 然后就可以在电脑上访问到 NAS 中的资料了。其他设备访问也比较容易，手机上可以用 Solid Explorer （需付费）或者 ES文件浏览器。电视上应该也有ES浏览器可以安装。 ios设备推荐使用 nPlayer，非常方便。 参考文章： Turn any hard drive into networked storage with Raspberry Pi Openmediavault入门常见问题及解决方法","tags":[{"name":"nas","slug":"nas","permalink":"http://zhzhou.me/tags/nas/"}]},{"title":"使用 Travis-CI 来自动化部署 Hexo","date":"2017-02-20T06:00:00.000Z","path":"2017/02/20/auto-deploy-hexo-on-travis-ci/","text":"之前写过一个 Hexo 博客的搭建方法，搭建好之后我就没有怎么写博客了。一来是因为自己没什么好分享的（其实就是懒哈），二来是感觉静态技术博客这种形式已经落伍了，如果要学某种技术，还是直接找视频教程比较快。 不过因为知道了“持续集成”，即 Continuous integration，这种技术已经很常见了，不过我最近才学习到。用在 hexo 博客的部署上比较合适，整个部署也比较简单，适合我这种小白。 之前部署 hexo 博客，只要在终端输入 hexo g -d即可，当然前提是你已经写好文章了呀，写不出文章的话我是帮不了的。而且已经搭建好博客环境，即 node.js 相关及 Hexo 本身。那换成 Travis CI 的持续集成服务到底有什么用呢？操作会不会更简单？答案是—–不会！ 那TM要它有什么用？！ 且听我慢慢说。 什么叫持续集成网上很多解释，感兴趣的可以看看阮一峰的这篇文章。 概括起来讲，就是一个外包公司，博主只管写好文章，然后丢给它去处理，它就自动给你各种加工渲染，然后放到博客页面上去。你只需在有网络的地方即可开始写作，当然也要能无障碍访问 GitHub 才行啊（关于如何更快访问墙外网络，我会在之后一篇文章说明）。直接登录 GitHub 账号写东西，实在不够优雅，所以还要弄个 Markdown 编辑器，本地或者基于 Web 的都可以（Mac 推荐用 Bear，web的就用 Cmd Markdown），写完直接 push 到 GitHub 即可，其他各种库、主题什么的更新都不用管了。这才是新时代的方法—-只要提出需求，然后交给“云”处理。 Travis-CI 介绍Travis CI 是目前新兴的开源持续集成构建项目，用来构建托管在GitHub上的代码。简单来说，Travis CI原理就是当你每次提交 commit 到在 GitHub 后，它会自动检测你的提交，同时根据的配置文件，生成一个 Linux 虚拟机来运行你的命令，通常这些命令用于测试，构建等。在我们的要求下，就可以用它运行一些hexo g d之类的命令来自动生成、部署我静态网页。好像不是很懂，没关系，做一遍就懂了。 Travis-CI 官方文档，有时间，懂英语的可以仔细看看。写得最好的还是官方文档，一般我们总是各种找教程什么的，其实最好的教程就是自带的文档。 自动部署看到这里，应该都有了 GitHub 的 Pages了，不然也不会涉及到部署什么的。下面步骤前提是在你电脑上可以 hexo g -d成功的前提下进行的。 登陆Travis CI官网，使用GitHub账户登录，发现你的 repos都出现了吧。然后关键了。选择你要启动的项目，在这里也就是yourname/yourname.GitHub.io，你的博客项目地址。 然后点击设置按钮，进入设置选项，开启第一行的服务: Build only if .travis.yml is present：是只有在.travis.yml文件中配置的分支改变了才构建； Build pushes：当推送完这个分支后开始构建。 到这一步， 我们已经开启了要构建的仓库。但此时Travis还没法帮助我们自动构建并部署，因为没有访问GitHub的权限。我们自己在本地计算机上push能成功是因为有了 SSH key，但是交给 travis去部署的话，它是没有这个key的，但是也可以给它，只要加密再解密就好了，配置文件配置可以参考文末的链接。不过我这里就用GitHub提供的token变量功能吧，比较适合新手。 在 GitHub 上为 Travis CI 配置 Acess Token，登陆GitHub，进入设置界面，点击到 Personal access tokens 页面。 点击右上角的Generate new token 按钮会生成新的token，点击后提示输入密码后继续，然后来到如下界面，取个名字（我这里取 GH_token，下面配置文件中要用到，牢记！），勾选一些权限（只要repo就行了，还有email），这个token很重要，如果别人也有了这个token，你GitHub账户的repo就可能被任意修改！！所以不能外泄这个token！重要的事情就不说三遍了。不过如果外泄了，登录你的GitHub，删除这个token即可。 生成完后，拷贝下来，只有这时候才会显示，下载进来为了安全他就不会显示了，如果忘了只能重新生成一个了，拷贝完以后到Travis CI页面中 Environment Variables 进行配置。 现在 Travis CI 已获得 GitHub 访问权限，但它并不知道如何进行部署，所以还需要进一步设置。 在源代码分支（我这里即 blog-source 分支）下配置 .travis.yml 文件 1234567891011121314151617181920212223242526272829303132333435363738language: node_js #设置语言node_js: stable #设置相应的版本cache: directories: - node_modules #据说可以减少travis构建时间before_install: - git clone https://github.com/zpike/hexo-theme-apollo.git themes/apollo #自己配置一个主题，也是乐趣之一，特效什么的，不过我还是偏好简洁（Next主题用的人真是多啊）# S: Build Lifecycleinstall: - npm install #安装hexo及插件before_script: - git clone --branch master https://github.com/zpike/zpike.github.io.git public #获取最新的commit信息script: - hexo cl #清除 - hexo g #生成after_script: - cd ./public - git init - git config user.name \"zpike\" #修改成自己的github用户名 - git config user.email \"conan401@126.com\" #修改成自己的GitHub邮箱 - git add . - git commit -m \"update\" - git push --force --quiet \"https://$&#123;GH_token&#125;@$&#123;GH_REF&#125;\" master:master #GH_token就是在travis中设置的tokenbranches: only: - blog-source #只监测这个分支，一有动静就开始构建（我可能发一篇文章会push好多次，每次看到它忙着构建，感觉好浪费）。env: global: - GH_REF: github.com/zpike/zpike.github.io.git 大致结构就是这样，根据自己的需求还需要一点修改。 .travis.yml 配置完成，这个时候就可以push文章到你的 blog-source 分支上去了。然后其他工作都由 Travis-CI 来完成。 登陆Travis CI，不出意外的话（我出了好多次意外，不过最终皇天不负有心人！哈哈）Travis已经检测到变化并进行构建部署，log记录了构建的过程，出什么问题里面都可以点开来看。 常见问题配置文件如果出问题，基本都是配置文件的问题，yml文件的格式还是要求比较严格的，稍微不注意就不行。.travis.yml 文件的主要流程分三步，获取历史，生产静态文件，发布。 before_script: 在所有动作之前，先把 master 分支clone到./public文件夹，保留之前的 commit记录，把最新结果提交上去。 script: 就是 hexo generate的过程。 after_success: 在成功之后，成功都到了public文件夹下，然后就是照着git push到master分支下。 当然还需要确认travis build都在 blog-source分支下工作。 主题设置网上很多hexo的主题，有的还在持续更新，这个就需要在配置文件中clone 一下，保持更新，或者在package.jason文件中配置一下也行吧（没试过），还是在travis配置文件中设置一下，方便换主题。设置在 before_install 后面。 git命令这套方案弄完之后，在任何电脑，只要有git，就可以写东西了。git指令如何操作呢？ 新手可能会比较麻烦。比如我。虽然我很早就用过git，不过很多指令学了忘，忘了学。其实最好的学习就是不断使用，如果几周不用，再好的工具也记不住。比如vim或者emacs。 git新手建议看看廖雪峰的博客，还有git-scm，还有git-tower官网的很多教程，写得非常好，图文并茂，入门书籍的话应该无出其右了。 不过在写博客这方面，只需要记住几个常用的命令就行了。 1234567git clone git@github.com:zpike/zpike.github.io.git #先克隆git checkout origin/blog-source #默认是master分支，然后切换分支git checkout -b blog-source #本地新建一个博客源文件分支git add . #写完博客添加文件git commit -m &quot;xxx&quot; #加入commit信息git push origin blog-source #push到远程 记住以上必用的命令当然不够，为了更方便操作，还是需要多多记住一些常用的git命令。 如果在web上直接写文章的话，看下面。当然不建议这么做啦，不过如果身边没有设备的话，只有一只手机，那也没办法。灵感来了挡不住呀。 prose这个网站不错，很清爽，然后可以和Github 绑定，这样就可以直接在这上面写你的Pages博客了，写好直接save，搞定！。网页端暂时只有这个我比较满意。 好的客户端还在寻找中，如果Bear或者Ulysses支持就好了，或者好像Tower是管理GitHub的利器，不行也可以那里写，只是不知道markdown支持如何。 不过虽然可以直接写，但是很多Hexo的特性就用不到了，比如一些模版什么的，每次还要自己输入元数据，还是稍显麻烦。 总结现在终于可以anywhere, anyplatform, anyeditor都可以开始写作了，还是很不错的。要做的就是打开editor，然后写完push即可，不用操心其它，多美好！ 在工具的路径上是没有止境的，生命不息，折腾不止。 参考资料使用 Travis CI 自动部署 Hexo 使用 Travis CI 自動發布 hexo 到 GitHub pages 基于 Hexo 的全自动博客构建部署系统 用 Travis CI 自動部署網站到 GitHub(Hexo 作者写的)","tags":[{"name":"hexo travis","slug":"hexo-travis","permalink":"http://zhzhou.me/tags/hexo-travis/"}]},{"title":"Chrome 插件推荐","date":"2016-08-12T06:00:05.000Z","path":"2016/08/12/chrome-extensions-recommend/","text":"自从科学上网之后，用Chrome的次数也明显增多。就目前来看，相对最好用的就它了，不过也分情况，如果只是简单上上网，又在 Mac 下，还是建议用 Safari，不然温度吓死人。不过最近升级之后没那么夸张了，Mac也不会太热。 下面说几个觉得比较好用的插件。(会保持更新，觉得一般的或者有可以代替的会说明) 首先要说的是翻墙，因为如果不是建立在翻墙的基础之上，Chrome的使用无从谈起。当然网上很多翻墙教程啦，我这里不多说，目前我用得最好的还是ss，几家做得好的，比如Linode，bandwagon，Vultr等。国内也很多，我目前用的chromegae的，速度不错，偶尔有些小问题。不管哪家服务，服务器位置比较重要。香港，台湾，日本，韩国的服务器比较好。 建议直接用路由器翻墙，路由里面的ss才是真的ss，即使小飞机已经很方便了，但还是会涉及打开关闭软件的问题，iOS平台目前还没有ss客户端，有个surge但是超级贵。所以关于如何翻墙，还是直接路由级别的翻墙才是真翻墙，这样你的ps4，你的电视里的youtube或者netflix，你的linux升级，都能享受到。你会慢慢感受不到墙的存在。 One Click Extension Manager — “快捷拓展管理-无广告版”，这个是用来管理你的插件的，根据自己当时的情况有的插件暂时不要用的，但是又不想删了的，可以用来管理下，非常方便。毕竟插件太多了，会导致占用内存太多，电脑变卡。 然后自己用的比较多的是印象笔记·剪藏，这个东西目前看速度最快，不管墙外墙内。还可以搜索之前的文章，配合 Google 搜索非常好用。裁剪的文章也可以放到固定的目录，简直完美。其他的如instapaper或者keep或者pocket等，都都没这个好用。建议只用一个此类收藏网络文章的软件，管理起来也比较方便，也方便记忆。 然后广告拦截也是非常重要的一个，这里我用Adguard广告拦截器，做得很好，功能强大，几乎全平台适用。不过有一些限制，付费买完整版的功能更多一点，不过自己也没用过，有兴趣的可以去官网看看，一年一百多，还不错。广告类的还有AdBlock，ADfree，不过目前有的视频网站直接检测到被拦截，还是要你等待，挺恶心的。不过其他广告拦截还是不错的。 还有查单词也是很重要的需求之一，都Google了，看下国外的各种网站当然是必须的，比如 New Yorker 之类，用的高级词汇还挺多，win下没有方便的查单词手势就用插件吧，Google Dictionary还不错，不过只能一次看一种语言的解释，而且还需翻墙。还有一个Ddict Translate，效果也很不错。 Stylish这个插件是美化一些常用网站的，比如baidu，zhihu什么的。效果很好，对视觉要求比较高的推荐使用，不过会带来一定的速度损失啦。 然后推荐一下WakaTime，这个是统计你在网上所用时间分布的插件，配合 Sublime Text 插件还可以统计你编程各类语言的时间，非常神奇。 开发类的插件众多，做前端的有很多非常好用插件，这里推荐 ColorZilla，找网站颜色比较方便。还有Web Developer，几乎什么都集中在里面了，神器。 Checker Plus for Gmail这插件还不错，可以提示你邮箱内的情况，很方便。不过最近出了个Black Menu for Google，整合了google的基本所有功能，用起来更方便。 Pushbullet，这个插件也不错，特别是你如果有几个手机，装一个这个插件，来电或者任何信息，都可以不用看手机了，直接电脑上可以看。当然这个插件还有其他功能，不过这个对我来说最有用。很推荐。 Diigo，用来收集网络文章之类，截图，做标记等。做得很全面，很不错。截图的还有Nimbus Screenshot &amp; Screen Video Recorder，做得也相当不错，很多功能，我还没怎么使用，先收着。 Ghostery，用来隐私浏览，看谁在跟踪你的网站浏览。 如果经常看wikipedia页面的话，建议用Wikiwand，效果很不错， HTTPS Everywhere，安全浏览。 JSONView，检查并查看json文件。 ReRes，用来更改页面请求响应的内容。通过指定规则，您可以把请求映射到其他的url，也可以映射到本机的文件或者目录。 Vimium，神器！值得学习一阵，熟悉vim的用这个会觉得很爽。 Mosh，据说比ssh更稳定。 JetBrains IDE Support，用jetbrains网页端的软件开发，用这个插件来测试。 Disable HTML5 Autoplay，有些网站自动播放视频很讨厌，比如facebook，这个插件解决这个问题。 眼不见心不烦，目前最好的新浪微博插件，不过还是建议用客户端吧，微博首页真是丑爆。 Musixmatch Lyrics for YouTube，youtube上看视频音乐，可以看歌词。 Magic Actions for YouTube，神器。基本你看youtube视频所有的要求它都有了。 Photo Zoom for Facebook，可以自动大图facebook。不过感觉facebook热度过了，最近很少登录了，网站感觉垃圾了，没什么可看的。 最后谈几个apps。 Telegram，wechat太乱了，这里还挺清爽，有营养的谈话比较多一点。不过现在居然也要翻墙了。 feedly，常用来看rss的，win上没有reedly还是用这个吧。 draw.io Diagrams，这个用来画画流程图，还是蛮方便的。","tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://zhzhou.me/tags/Chrome/"}]},{"title":"Hexo 搭建笔记","date":"2016-07-07T08:07:16.000Z","path":"2016/07/07/how-to-create-a-hexo-blog/","text":"很久以前看过阮一峰的介绍 Jekyll 做个人博客的文章，那时候还没用 Mac，所以也没法尝试。现在用了Mac之后想起来了，不过写博客还是挺费力的，没啥干货也不好意思出来唠叨。尽量写点有趣又有科技含量的东西吧，逼着自己更新知识库还是不错的。 Jekyll的官网虽然做得不错，但是流程我还没看明白，比Hexo的说明要复杂。所以下面就从弄Hexo博客开始吧。 这几天折腾了一个Hexo博客，并且部署到GitHub和Coding，而且租了个服务器，弄个了个人域名，过程中几个小问题搜了很多文章，但是也没能解决我的问题，还是挺费劲的。第一篇文章就用来记录这个过程我遇到的问题吧。 网上信息比较多，很多过期的文章，软件版本更新之后就不大能用了，PC和Mac下的区别较多，给新手会造成不必要的误解。 官网可以查到的东西我就不再写了，下面多写写自己这个过程中遇到的一些问题。 Hexo是一个台湾人弄的，不知道靠不靠谱，希望可以一直更新吧，毕竟用起来整体感觉还不错，轻快简单。 很多人推荐使用NexT主题，搜了一下发现好多人用这个主题，瞬间感觉没啥特点了。所以要想独特一点，有个性一点还是自己找个冷门点的主题改改，或者自己弄个主题，只要专注于写作就行。 安装过程比较简单，不说了。Hexo安装依赖于node.js，npm安装比较不稳定，开个VPN比较好一点。Hexo官网上面的文档挺全的，需要补充的就是主题的设置，还有网站的第三方服务的设置。 Hexo的配置都在_config.yml中，里面注释比较详细，不懂的查下官网，一般都知道怎么设置。需要注意的是文件类型是yml，语法要求比较严格，开头冒号后面必须空一格，不然不能识别。语法支持好的比如vim或者sublime，弄个插件，一般都能很好支持yml语法。还有这个文件要和主题目录下的同名文件相互区别，不要弄混淆了。 具体设置，比如language，中文简体的代码是zh-hans，其他设置试一下就知道了，一般默认就ok了。头像，logo什么的，弄个url比较好，或者放到Hexo的source目录下，这样Hexo g 的时候才能不丢失。 配置测试ok了，然后就可以写blog了。Hexo new 加文件名即可。这样就在source文件夹下新建了一个文件，写好标签和分类，就可以写正文了。网上有教你Hexo new之后直接打开编辑器的教程，这样就更方便了。直接在sublime中或者其他编辑器中写文章。需要注意的是Win下目录设置的问题。类似这样D:\\\\Program Files\\\\Sublime Text 3\\\\...。Mac中的话就比如这样&quot;/Applications/Sublime\\ Text.app&quot;，注意空格之前要加一个反斜杠。（不过Sublime并不大适合写文章，MWeb据说不错可以试试） 其实还可以使用Cmd Markdown在线写文章，然后导出markdown格式，再稍微修改即可发布了。不过过程稍微麻烦了点。喜欢移动写作的人，估计会比较喜欢。不过最近我将hexo固定到air上来写，所有其他电脑上的文件都删除了。这样还是更适合我一点。（当然在这之前，你还是可以尽量折腾，比如自动构建什么的） 写文章不满意，当然也可以删掉，但是Hexo没有提供删除文章的命令，所以手动删掉也行，不过我测试了一下，在删光文章的时候Hexo g会出错，一定要hexo new一篇文章才能进行Hexo g。 再然后就是配置主题什么的了。建议看看NexT主题的官网，里面有详细的教程，非常实用，很多官网没看明白的东西可以在那边看看。比如字体，图标，第三方服务什么的。主题其实也是个大坑，最近就不研究了。专注写作比较好。当然第三方服务可以看看，毕竟要用到不少，比如评论系统， 最后写好文章就可以推送到 github pages 上去了。GitHub或者Coding都不错，国内建议用Coding，速度很快。不过很多人遇到Hexo d的时候不成功的问题，我也被这个问题折磨了很久，网上很多回答都没有解决我的问题。 其实直接将public中的生成文件push到pages就行了，只是这样不够优雅。所以还是希望一条命令（Hexo g -d）解决部署，在Mac问题较少，Win用户貌似要多写点配置内容，不过基本用我下面写的配置内容一定可以成功的。 首先想要部署到GitHub需要安装一个插件，Hexo-deployer-git，这个插件里面的文档作用比各种网上的文件要有用太多，建议看看。最终解决我的Hexo d的问题就是看了那个文档。因为我是Win下Git bash环境，所以Hexo d会出现问题，配置文件中需要这样写： 12345678# Deployment## Docs: https://Hexo.io/docs/deployment.htmldeploy: type: git repo: git@GitHub.com:name/name.GitHub.io.git branch: master user: your_GitHub_username email: your_email_address 当然前提是你ssh密钥以及GitHub或者Coding上主页都弄好了，具体看下各个网站的详细说明，Coding上比较容易，GitHub 稍复杂，跟着帮助文档过一遍流程就更熟悉了。 还有hexo g的时候可能会出现一些常见的问题，比如什么DTraceProviderBingds之类的，貌似是npm的问题，我之前遇到过，不过瞎弄了几次，居然莫名其妙就好了，暂时不知道为啥。 国内的duoshuo不行了，只能换到disqus上去了，不过我的博客总是加载不了disqus的服务，不知道为什么。索性就不用评论系统了，但是会保持的更新的。继续完善每个主题的文章。 最后列一下这个过程中用到的网站，方便查询。 Hexo官网文档 NexT主题官方网站详细配置 Coding Pages使用文档 Hexo怎么优雅地插入图片 Hexo添加文章时自动打开编辑器 多说评论 Hexo进阶 ps：还有图床可以用iPic，Mac 上面很好用，或者在 Windows 上面可以用MPic，配合七牛都是神器。直接复制图片，即可在md文件中粘贴。 还有很多 markdown 中可以用到的插件，或者工具，会为你的文章添加更多色彩，这些我准备再多研究下，再写几篇文章。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://zhzhou.me/tags/hexo/"}]},{"title":"单片机上电启动流程及相关配置详解","date":"2016-02-18T16:00:00.000Z","path":"2016/02/19/mcu-powerup/","text":"单片机执行程序的过程，实际上就是执行所编程序的过程，即逐条指令的过程。执行一条指令都可分为三个阶段进行，即取指令---分析指令---执行指令。取指令的任务是：根据程序计数器PC中的值从程序存储器读出现行指令，送到指令寄存器。 分析指令阶段的任务是：将指令寄存器中的指令操作码取出后进行译码，分析其指令性质。如指令要求操作数，则寻找操作数地址。 单片机执行程序的过程实际上就是逐条指令地重复上述操作过程，直至遇到停机指令、可循环等待指令。 单片机中的程序一般事先我们都已通过写入器固化在片内或片外程序存储器中，因而一开机即可执行指令。 下面用一个实例来说明指令的执行过程。 开机时，程序计数器PC变为0000H。然后单片机在时序电路作用下自动进入执行程序过程。执行过程实际上就是取出指令和执行指令的循环过程。 例如执行指令：MOV A,#0E0H，其机器码为“74H E0H”，该指令的功能是把操作数E0H送入累加器，0000H单元中已存放74H（该命令代表向A累加器写入立即数），0001H单元中已存放E0H。 当单片机开始运行时，首先是进入取指阶段，其次序是： PC的内容（这时是0000H）送到地址寄存器； PC的内容自动加1（变为0001H）； 地址寄存器的内容（0000H）通过内部地址总线送到存储器，以存储器中地址译码电跟，使地址为0000H的单元被选中； CPU使读控制线有效； 在读命令控制下被选中存储器单元的内容（此时应为74H）送到内部数据总线上，因为是取指阶段，所以该内容通过数据总线被送到指令寄存器。 至此，取指阶段完成，进入译码分析和执行指令阶段。 由于本次进入指令寄存器中的内容是74H（操作码），以译码器译码后单片机就会知道该指令是要将一个数送到A累加器，而该数是在这个代码的下一个存储单元。所以，执行该指令还必须把数据（E0H）从存储器中取出送到CPU，即还要在存储器中取第二个字节。其过程与取指阶段很相似，只是此时PC已为0001H。指令译码器结合时序部件，产生74H操作码的微操作系列，使数字E0H从0001H单元取出。因为指令是要求把取得的数送到A累加器，所以取出的数字经内部数据总线进入A累加器，而不是进入指令寄存器。 至此，一条指令的执行完毕。 单片机中PC=0002H，PC在CPU每次向存储器取指或取数时自动加1，单片机又进入下一取指阶段。这一过程一直重复下去，直至收到暂停指令或循环等待指令暂停。CPU就是这样一条一条地执行指令，完成所有规定的功能。 单片机上电后ROM与RAM执行流程简单介绍 ROM：(Read Only Memory)在单片机中用来存储程序数据及常量数据或变量数据，凡是c文件及h文件中所有代码、全局变量、局部变量、常量数据、startup.asm文件中的代码(类似ARM中的bootloader或者X86中的BIOS，一些低端的单片机是没有这个的)通通都存储在ROM中。 RAM：(Random Access Memory)用来存储程序中用到的变量。凡是整个程序中，所用到的需要被改写的量，都存储在RAM中，“被改变的量”包括全局变量、局部变量、堆栈段。 程序经过编译、汇编、链接后，生成hex文件。用专用的烧录软件，通过烧录器将hex文件烧录到ROM中。因此，这个时候的ROM中，包含所有的程序内容：无论是一行一行的程序代码，函数中用到的局部变量，头文件中所声明的全局变量，const声明的只读常量，都被生成了二进制数据，包含在hex文件中，全部烧录到了ROM里面。 此时的ROM，包含了程序的所有信息，正是由于这些信息，“指导”了CPU的所有动作。 ROM中包含所有的程序内容，在MCU上电后，CPU开始从第1行代码处执行指令。这里所做的工作是为整个程序的顺利运行做好准备，或者说是对RAM的初始化，工作任务有几项： 为全局变量分配地址空间 如果全局变量已赋初值，则将初始值从ROM中拷贝到RAM中，如果没有赋初值，则这个全局变量所对应的地址下的初值为0或者是不确定的。当然，如果已经指定了变量的地址空间，则直接定位到对应的地址就行，那么这里分配地址及定位地址的任务由“连接器”完成。 设置堆栈段的长度及地址 用C语言开发的单片机程序里面，普遍都没有涉及到堆栈段长度的设置，但这不意味着不用设置。堆栈段主要是用来在中断处理时起“保存现场”及“现场还原”的作用，其重要性不言而喻。而这么重要的内容，也包含在了编译器预设的内容里面，确实省事，可并不一定省心。 分配数据段data，常量段const，代码段code的起始地址 代码段与常量段的地址可以不管，它们都是固定在ROM里面的，无论它们怎么排列，都不会对程序产生影响。但是数据段的地址就必须得关心。数据段的数据时要从ROM拷贝到RAM中去的，而在RAM中，既有数据段data,也有堆栈段stack，还有通用的工作寄存器组。通常，工作寄存器组的地址是固定的，这就要求在绝对定址数据段时，不能使数据段覆盖所有的工作寄存器组的地址。 注意： 这里所说的“第一行代码处”，并不一定是你自己写的程序代码，绝大部分都是编译器代劳的，或者是编译器自带的demo程序文件。高级一点的单片机，这些内容，都是在startup的文件里面。 通常的做法是：普通的flash MCU是在上电时或复位时，PC指针里面的存放的是“0000”，表示CPU从ROM的0000地址开始执行指令，在该地址处放一条跳转指令，使程序跳转到_main函数中，然后根据不同的指令，一条一条的执行。 当中断发生时(中断数量也很有限，2~5个中断)，按照系统分配的中断向量表地址，在中断向量里面，放置一条跳转到中断服务程序的指令，这样，整个程序就跑起来了。 I/O口寄存器：可以被改变的量，它被安排在一个特别的RAM地址，为系统所访问，而不能将其他变量定义在这些位置。 中断向量表：中断向量表是被固定在MCU内部的ROM地址中，不同的地址对应不同的中断。每次中断产生时，直接调用对应的中断服务子程序，将程序的入口地址放在中断向量表中。 CodeWarrior执行步骤 初始化堆栈，堆栈是通过编译参数的传递过来的； 初始化内存，将内存清零，从ROM区复制数据到特定的内存区； 调用main函数 CW创建的工程包括以下几个部分： Sources文件夹下面放的是源代码，mian.c为主函数所在文件，若要新建源文件也要放在此文件夹下面。datapage.c文件为数据页面配置文件，一般写程序用不到，与编译有关，不可删除。 Startup Code文件夹下面的Start12.c文件是开发环境编译时默认的最先执行的一段程序，在Start12.c的最后调用main.c的主函数。在Start12.c中，创建工程所要注意的是对地址的重分配映射。 Linker Files文件夹下面的prm文件里面是关于整个工程在编译连接时的一些规则设置，在此文件中，要注意的是RAM和ROM的地址定义和堆栈大小。 使用监控程序进行程序烧写调试的方法说明对单片机进行调试、程序烧写可以有两种方式: 用BDM通过专门接口进行 利用监控程序通过串口进行 BDM方式是芯片厂商提供的调试、烧写方式，在MCU上留有管脚，通过仿真器将目标板和PC相连，PC通过Hiwave程序将程序通过仿真器烧写到MCU中。BDM的一大特点是需要专门的仿真器和开发环境，在没有仿真器或者Hiwave程序时就无法进行程序的烧写。 另一种方式是利用监控程序通过串口进行程序烧写的方式，不用专门的调试器，不用专门的程序就可以进行程序的烧写。 原理： 通过串口烧写程序就是用已经烧写在单片机内部的一小段程序，通过异步串行接口与PC机通信，把得到的程序数据写到MCU的Flash中。 已烧写进MCU的程序称为监控程序(官方提供)在提供开发板之前已用BDM烧写进MCU内。 由于监控程序的存在，单片机一些存储空间被占用，中断向量表的位置也要改变。 已有监控程序的单片机在运行时，首先运行的程序就是监控程序，监控程序首先会等待3秒，同时查询串口是否接收到任何数据，若接收到数据，就进入调试状态，通过指令进行程序烧写、调试。若3秒内没有从串口上接收到数据，就去执行用户烧写到MCU内的程序。 使用CW进行程序编写时的注意事项： 由于使用了监控程序，在进行程序编写时就要比平常多注意两个方面的东西，一是对整个程序存储空间的定义，一是中断向量的偏移。 程序存储空间的定义： 监控程序占用了$F000~$FEFF的存储空间，并且通过串口烧写程序时对此存储空间进行了写保护，故用户在写程序时要注意必须将程序编译连接至此存储空间中。为了解决此问题，要在prm文件中进行改动，如下：ROM_C000 = READ_ONLY 0xC000 TO 0xEEFF; 中断向量表偏移的处理： 监控程序将中断向量表从$FF00~$FFFF偏移至$EF00~$EFFF, 即用户的程序入口和中断程序的向量号需要改变。 程序入口的改变在prm文件中改动，如下：VECTOR 0 _Startup 改为 VECTOR 2048 _Startup各中断程序的向量号，需要在原来的基础上加上2048。 一般情况下Start12.c中的设置(利用监控程序通过串口进行) 在创建的CW工程中，Start12.c文件中没有对各存储单元进行地址重分配，造成了地址的重叠，为了解决这个问题，需要在Start12.c中进行一些改动，把各存储单元进行地址重映射，充分利用各存储单元。具体改变如下： 第118行：1234567#ifdef _HCS12_SERIALMON /* for Monitor based software remap the RAM &amp; EEPROM to adhere to EB386. Edit RAM and EEPROM sections in PRM file to match these. */#define ___INITRM (*(volatile unsigned char *) 0x0010)#define ___INITRG (*(volatile unsigned char *) 0x0011)#define ___INITEE (*(volatile unsigned char *) 0x0012)#endif 注释掉#ifdef和#endif开头的两行。416行改动一样。 prm文件的设置(利用监控程序通过串口进行) 在prm文件中，由于在Start12.c中进行了地址的重映射，所以要改动RAM和ROM的地址定义。另外，如果编写的程序需要较大的栈（比如多重的程序调用，中断嵌套），还要改变堆栈的大小。ROM的地址定义在一般情况下不用改变，但在使用监控程序进行程序下载、调试时，由于单片机里面本身已经含有一段监控程序，并且监控程序在烧写用户程序是对自己所占据的地址空间是自我保护的，所以在使用监控程序时要在prm中改动ROM的地址定义使用户程序不与监控程序冲突。 RAM的地址定义： RAM = READ_WRITE 0x2000 TO 0x3FFF; 若要改变堆栈的大小： 将STACKSIZE 0x100后面的0x100改为所需大小。 经过以上步骤，就可以建立一个可以使用的工程框架，就可以进行各用户的程序编写了。 在CW中指定堆栈大小及堆栈指针CodeWarrior自动生成的工程中堆栈指针的初始化机制打开CodeWarrior中的一个新建工程，在Start12.c文件中可以看到语句“INIT_SP_FROM_STARTUP_DESC()”，这是系统自动生成对堆栈指针的初始化语句。 这条语句是个宏函数，具体为#define INIT_SP_FROM_STARTUP_DESC() __asm LDS #__SEG_END_SSTACK;其中__SEG_END_SSTACK是由编译器根据配置文件自动生成的，从而达到按照用户要求配置堆栈指针的目的。 几种不同的堆栈的内存分布及配置方法 RAM区的开始是堆栈区，随后是数据区 这时堆栈区的大小由prm文件中STACKSIZE参数指定，而SP的具体值由编译器根据指定的堆栈区大小计算得出。 这个内存分布是新建工程的默认配置，是由prm文件中PLACEMENT区语句：“SSTACK, DEFAULT_RAM INTO RAM;”决定的。 当把语句换成：“DEFAULT_RAM, SSTACK INTO RAM;”时，RAM区的分布会变为开始是数据区，随后才是堆栈区。 而且，当不指定SSTACK在内存中分布时，即语句变为：“DEFAULT_RAM INTO RAM;”时，RAM区的分布也会变为开始是数据区，随后才是堆栈区. 堆栈区在RAM区任意位置 实现这种分布有两种方法： I. 利用prm文件 这时SP的值由prm文件中STACKTOP参数指定（需要用户自己添加），堆栈区的大小也需要在prm文件中自己指定，例子如下：1234567891011SEGMENTSMY_STK = NO_INIT 0xB00 TO 0xBFF;MY_RAM = READ_WRITE 0xA00 TO 0xAFF;MY_ROM = READ_ONLY 0x800 TO 0x9FF;ENDPLACEMENTDEFAULT_ROM INTO MY_ROM;DEFAULT_RAM INTO MY_RAM;SSTACK INTO MY_STK;ENDSTACKTOP 0xB7E 本例中堆栈区大小为从0xB7E到0xB00，SP的值为0xB7E。 注：在并不关注堆栈区的位置而仅仅关注堆栈区大小的情况下，CodeWarrior推荐用STACKSIZE的方式定义堆栈，即此时不推荐用STACKTOP的方式。 II. 在start12.c文件中自己指定 在函数_Startup的开始用语句：__asm LDS #VAR;(VAR为自己指定的SP的值)来指定SP的值，堆栈区的大小由prm文件中STACKSIZE参数指定。","tags":[{"name":"mcu","slug":"mcu","permalink":"http://zhzhou.me/tags/mcu/"}]}]